%% run_label3d.m
% Script to load data and launch the Label3D GUI for labeling two monkeys.

clear all;
close all;

% --- Add necessary paths ---
% Add paths to Label3D code and dependencies if not already on MATLAB path
addpath(genpath('deps')); % If Animator is in deps
addpath('.'); % Current folder for Label3D.m
fprintf('Setting up Label3D session...\n');

% =========================================================================
% --- Configuration ---
% =========================================================================

% Directory containing the ORIGINAL video files (used for deriving calib paths)
originalVideoDir = "A:\EnclosureProjects\inprep\freemat\data\experiments\good\240528\video\experiment\fixed_timestamp";
% Directory containing the CROPPED videos (if used)
cropVideoDir = "A:\EnclosureProjects\inprep\freemat\data\experiments\good\240528\video\experiment\fixed_timestamp\crop1min_cropped_videos";
use_cropped_videos = true; % Set to true to load from cropVideoDir, false for originalVideoDir

poses_data = "A:\EnclosureProjects\inprep\freemat\data\experiments\good\240528\video\calibration\fixed_timestamp\multical\monkey_pose_output\imgs\posesfor3d.mat";

% --- Camera and Video Paths ---
% Define the camera names IN THE ORDER YOU WANT THEM LOADED/DISPLAYED
% This order must match the order of param files loaded
labelingCameraNames = {
    "Cam_001",
    "Cam_002",
    "Cam_003",
    "Cam_004",
    "Cam_007",
    "Cam_008",
    "Cam_009",
    "Cam_010",
    "Cam_011",
    "Cam_012", 
    "Cam_013",
    "Cam_014",
    "Cam_015",
    "Cam_016",
    "Cam_018",
    "Cam_019",
    "Cam_020",
    "Cam_021",
    "Cam_022",
    "Cam_023",
    "Cam_024",
    "Cam_025",
    "Cam_026",
    "Cam_027",
    "Cam_028"
    };

% --- Define which CAMERAS (from labelingCameraNames) to load poses for ---
camerasToLoadPosesFor = {"Cam_001", "Cam_002", ...
    "Cam_003", ...
    "Cam_004", "Cam_007"
    };
numCameras = numel(labelingCameraNames);

% --- Specify Paths for Automatic Video Discovery ---
% *** Derive calibration paths from the ORIGINAL video directory ***
[baseVideoPath, ~, ~] = fileparts(originalVideoDir);
[baseVideoPath, ~, ~] = fileparts(baseVideoPath); % Go up two levels
calibrationBaseDir = fullfile(baseVideoPath, 'calibration', 'fixed_timestamp', 'multical');

% Path to the extraction report containing camera name mappings
extractionReportPath = fullfile(calibrationBaseDir, 'extraction_report.txt');

% Directory containing *_params.mat files
paramDir = fullfile(calibrationBaseDir, 'label3d');

% --- Calibration and Skeleton Paths ---
% paramDir = "A:\EnclosureProjects\inprep\freemat\experiments\good\240528\video\calibration\fixed_timestamp\multical\label3d"; % Directory containing *_params.mat files - REMOVED
skeletonFile = fullfile('skeletons', 'coco17_skeleton.mat');

% --- Labeling Parameters ---
labelingDurationMinutes = 60; % Duration from the start of the video to sample from
framesPerMinute = 3;          % Number of frames to select per minute
frameRate = 40;               % Video frame rate in fps (used for calculation, checked against actual)
nAnimals = 2;                 % Number of animals to label FOR THIS SESSION

% --- Output/Cache Configuration ---
labelingOutputDir = fullfile(pwd, 'labeling_output'); % Folder to save Label3D sessions
enableVideoCache = true;     % Set to true to save loaded frames for faster restarts
useParallel = true;          % Set to true if Parallel Computing Toolbox is available

% --- Debugging flags for frame selection ---
debug_use_first_N_frames_from_poses = true; % If true and loadPrecomputedPoses, takes only the first N frames
debug_N_frames_to_load = 5;                % Number of frames to load if debug_use_first_N_frames_from_poses is true

% =========================================================================
% --- Precomputed 2D Pose Configuration ---
% =========================================================================
loadPrecomputedPoses = true; % Set to true to load precomputed 2D poses
% Path to the .mat file generated by prepare_label3d_poses.py
% precomputedPoseMatPath = fullfile(labelingOutputDir, 'all_poses_for_label3d.mat'); 
precomputedPoseMatPath = poses_data;

% --- Define which INSTANCES from the .mat file to load for this session ---
% These are the STRING INSTANCE IDs as discovered by the Python script 
% (and saved in 'discovered_instance_ids' in the .mat file).
% The order here defines the mapping to animals 0, 1, ... (or 1, 2, ... in MATLAB 1-based indexing)
% for the current Label3D session, matching nAnimals.
% Example: instanceIDsToLoadForSession = {'id_from_json_animal1', 'id_from_json_animal2'};
% Ensure these IDs exist in `discovered_instance_ids` in the .mat file.
% The number of elements in this cell array MUST match nAnimals.
instanceIDsToLoadForSession = {'1', '2'}; % CORRECTED based on user feedback that .mat contains {'1', '2'}

% =========================================================================
% --- Parse Extraction Report and Find Video Paths ---
% =========================================================================
fprintf('Parsing extraction report: %s\n', extractionReportPath);

if ~exist(extractionReportPath, 'file')
    error('Extraction report file not found: %s', extractionReportPath);
end

camNameToPrefixMap = containers.Map('KeyType', 'char', 'ValueType', 'char');

try
    fid = fopen(extractionReportPath, 'r');
    if fid == -1
        error('Could not open extraction report file: %s', extractionReportPath);
    end

    % Regex to find lines like: Camera: e3v8217-... (Cam_001)
    % It captures the first 7 chars (prefix) and the Cam_XXX name
    regexPattern = 'Camera:\s+(\w{7}).*\((Cam_\d{3})\)';

    tline = fgetl(fid);
    while ischar(tline)
        tokens = regexp(tline, regexPattern, 'tokens');
        if ~isempty(tokens)
            prefix = tokens{1}{1};
            camName = tokens{1}{2};
            camNameToPrefixMap(camName) = prefix;
        end
        tline = fgetl(fid);
    end
    fclose(fid);
catch ME
    if fid ~= -1, fclose(fid); end % Ensure file is closed on error
    rethrow(ME);
end

fprintf('Found mappings for %d cameras in the report.\n', length(keys(camNameToPrefixMap)));

% *** Determine which directory to load videos FROM ***
if use_cropped_videos
    videoSourceDir = cropVideoDir;
    fprintf('Using CROPPED videos from directory: %s\n', videoSourceDir);
else
    videoSourceDir = originalVideoDir;
    fprintf('Using ORIGINAL videos from directory: %s\n', videoSourceDir);
end

if ~exist(videoSourceDir, 'dir')
    error('Video source directory not found: %s', videoSourceDir);
end

% *** Search for videos in the determined videoSourceDir ***
% potentialVideoFiles = dir(fullfile(videoSourceDir, '*.mp4')); % We don't need to list all files if checking directly

videoPaths = cell(numCameras, 1);
foundCount = 0;
missingCameras = {};

for i = 1:numCameras
    currentCamName = labelingCameraNames{i};
    fprintf('  Looking for video for: %s... ', currentCamName);

    if ~isKey(camNameToPrefixMap, currentCamName) && ~use_cropped_videos % Only need prefix map if using original names
        fprintf('ERROR: Camera name %s not found in extraction report (needed for original video name prefix).\n', currentCamName);
        missingCameras{end+1} = [currentCamName, ' (Missing Prefix Map)'];
        continue; % Skip this camera
    end

    foundMatch = false;
    matchedFile = '';

    if use_cropped_videos
        % --- Search for cropped video named directly Cam_XXX.mp4 ---
        expectedFilename = currentCamName + ".mp4"; % CORRECTED: Use + for string concatenation

        % --- BEGIN MORE SPECIFIC DEBUG ---
        fprintf('  DEBUG (Before fullfile): videoSourceDir Class=%s, Size=%s, Value=\n', class(videoSourceDir), mat2str(size(videoSourceDir)));
        disp(videoSourceDir);
        fprintf('  DEBUG (Before fullfile): currentCamName Class=%s, Size=%s, Value=\n', class(currentCamName), mat2str(size(currentCamName)));
        disp(currentCamName);
        fprintf('  DEBUG (Before fullfile): expectedFilename Class=%s, Size=%s, Value=\n', class(expectedFilename), mat2str(size(expectedFilename)));
        disp(expectedFilename);
        % fflush(stdout); % Removed based on previous error
        % --- END MORE SPECIFIC DEBUG ---

        expectedFullPath = fullfile(videoSourceDir, expectedFilename); 
        
        % --- BEGIN DEBUG PRINT ---
        fprintf('  DEBUG (After fullfile): expectedFullPath Class=%s, Size=%s, Value=\n', class(expectedFullPath), mat2str(size(expectedFullPath))); % Changed label
        disp(expectedFullPath); 
        % fflush(stdout); % Removed based on previous error
        % --- END DEBUG PRINT ---
        
        if exist(expectedFullPath, 'file')
             matchedFile = expectedFilename;
             foundMatch = true;
        else
            % Try other common extensions if needed (e.g., .avi)
            % expectedFilename = [currentCamName, '.avi'];
            % expectedFullPath = fullfile(videoSourceDir, expectedFilename);
            % if exist(expectedFullPath, 'file')
            %     matchedFile = expectedFilename;
            %     foundMatch = true;
            % end
            pass; % Keep foundMatch = false if .mp4 not found
        end
        % No ambiguity check needed here as we look for an exact name

    else
        % --- Search for original video starting with hardware prefix ---
        prefix = camNameToPrefixMap(currentCamName); 
        potentialVideoFiles = dir(fullfile(videoSourceDir, [prefix, '*.mp4'])); % List files starting with prefix
        if isempty(potentialVideoFiles)
             % Optional: Check for other extensions like .avi
             % potentialVideoFiles = dir(fullfile(videoSourceDir, [prefix, '*.avi']));
             pass;
        end
        
        if numel(potentialVideoFiles) == 1
            % Found exactly one match
            matchedFile = potentialVideoFiles(1).name;
            foundMatch = true;
        elseif numel(potentialVideoFiles) > 1
            % Found multiple matches - ambiguous
            fprintf('ERROR: Ambiguous match! Found multiple files starting with prefix "%s" in %s.\n', prefix, videoSourceDir);
            % Display found files for debugging
            disp({potentialVideoFiles.name}); 
            matchedFile = ''; % Reset match
            foundMatch = false; % Treat as not found due to ambiguity
        else 
            % No files found starting with prefix
             foundMatch = false;
        end
    end

    % --- Assign path if found --- 
    if foundMatch && ~isempty(matchedFile)
        videoPaths{i} = fullfile(videoSourceDir, matchedFile);
        fprintf('Found: %s\n', matchedFile);
        foundCount = foundCount + 1;
    else
        if use_cropped_videos
             fprintf('ERROR: Cropped video file not found: %s\n', fullfile(videoSourceDir, [currentCamName, '.mp4']));
        elseif ~foundMatch && isempty(potentialVideoFiles) % Original name search failed - no files with prefix
             fprintf('ERROR: No video file found starting with prefix "%s" in %s.\n', prefix, videoSourceDir);
        elseif ~foundMatch % Original name search failed - ambiguous
             % Error message already printed above in the ambiguity case
             pass;
        end
        missingCameras{end+1} = currentCamName;
    end
end

% Final Check
if foundCount ~= numCameras
    if isempty(missingCameras)
         error('Could not find matching video files for all requested cameras, but missingCameras list is empty. Check logic.');
    else
         % Ensure missingCameras only contains strings before unique/strjoin
         validMissing = missingCameras(cellfun(@ischar, missingCameras));
         error('Could not find matching video files for all requested cameras. Missing/Ambiguous: %s', strjoin(unique(validMissing), ', '));
    end
else
    fprintf('Successfully found video paths for all %d requested cameras.\n', numCameras);
end
% =========================================================================
% --- END VIDEO PATH FINDING ---
% =========================================================================


% =========================================================================
% --- Calculate or Load Frames to Label ---
% =========================================================================
if loadPrecomputedPoses
    fprintf('--- Loading frame list from precomputed poses file ---\n');
    if ~exist(precomputedPoseMatPath, 'file')
        error('loadPrecomputedPoses is true, but precomputed pose .mat file not found: %s', precomputedPoseMatPath);
    else
        fprintf('Loading frame IDs from: %s...\n', precomputedPoseMatPath);
        poseMatData = load(precomputedPoseMatPath, 'processed_frame_ids');
        if ~isfield(poseMatData, 'processed_frame_ids')
             error('Precomputed pose .mat file (%s) does not contain the required \'\'processed_frame_ids\'\' field.', precomputedPoseMatPath);
        end
        
        all_processed_frame_ids = sort(poseMatData.processed_frame_ids); % Get all available frame IDs

        if isempty(all_processed_frame_ids)
            warning('No frame IDs found in processed_frame_ids from .mat file.');
            framesToLabelIndices = [];
            nFramesToLabel = 0;
        else
            fprintf('  Found %d total processed frame IDs in .mat file, ranging from %d to %d.\n', ...
                    numel(all_processed_frame_ids), min(all_processed_frame_ids), max(all_processed_frame_ids));
            
            if debug_use_first_N_frames_from_poses
                fprintf('  DEBUG: Using first %d frames from precomputed poses due to debug flag.\n', debug_N_frames_to_load);
                unique_frames = unique(all_processed_frame_ids); % Ensure uniqueness
                if numel(unique_frames) >= debug_N_frames_to_load
                    framesToLabelIndices = unique_frames(1:debug_N_frames_to_load);
                else
                    framesToLabelIndices = unique_frames; % Take all available if fewer than N
                    warning('  DEBUG: Requested %d frames, but only %d unique frames available.', debug_N_frames_to_load, numel(unique_frames));
                end
                nFramesToLabel = numel(framesToLabelIndices);
                if ~isempty(framesToLabelIndices)
                    fprintf('  Selected %d frames: %s\n', nFramesToLabel, mat2str(framesToLabelIndices));
                    fprintf('  Selected frame range: %d to %d.\n', min(framesToLabelIndices), max(framesToLabelIndices));
                else
                    fprintf('  No frames selected based on debug settings.\n');
                end
            else
                % --- Original Subsampling Logic ---
                maxFrameToConsider = 4800;
                samplingInterval = 3; % Take 1 every 3 frames

                % 1. Filter by max frame
                frames_below_max = all_processed_frame_ids(all_processed_frame_ids <= maxFrameToConsider);
                
                if isempty(frames_below_max)
                    warning('No processed frames found at or below the max frame (%d).', maxFrameToConsider);
                    framesToLabelIndices = [];
                    nFramesToLabel = 0;
                else
                    % 2. Subsample (select 1st, 4th, 7th, etc. from the filtered list)
                    framesToLabelIndices = frames_below_max(1:samplingInterval:end); 
                    nFramesToLabel = numel(framesToLabelIndices);
                    fprintf('  Selected %d frames by taking every %d frames up to frame %d.\n', ...
                            nFramesToLabel, samplingInterval, maxFrameToConsider);
                     if ~isempty(framesToLabelIndices)
                          fprintf('  Selected frame range: %d to %d.\n', min(framesToLabelIndices), max(framesToLabelIndices));
                     end
                end
                % --- End Original Subsampling Logic ---
            end

            % Ensure framesToLabelIndices is a row vector if not empty
             if ~isempty(framesToLabelIndices)
                 framesToLabelIndices = reshape(framesToLabelIndices, 1, []); 
             end
        end
    end
else
    fprintf('--- Calculating frame list based on duration and sampling rate ---\n');
    % --- This is the ORIGINAL frame calculation logic ---
    fprintf('Determining video lengths and calculating frame indices to load...\n');
    minTotalFrames = Inf;
    actualFrameRates = zeros(numCameras, 1);
    for i = 1:numCameras
        try
            % fprintf('  Checking video length: %s\n', videoPaths{i}); % Less verbose now
            vr = VideoReader(videoPaths{i});
            if vr.NumFrames == 0
                error('Video file %s seems to have 0 frames.', videoPaths{i});
            end
            minTotalFrames = min(minTotalFrames, vr.NumFrames);
            actualFrameRates(i) = vr.FrameRate;
            if abs(vr.FrameRate - frameRate) > 1
                 warning('Video %d (%s) frame rate (%.2f) differs significantly from configured rate (%.2f)', ...
                         i, videoPaths{i}, vr.FrameRate, frameRate);
            end
        catch ME
            error('Could not read video file %s to determine length. Error: %s', videoPaths{i}, ME.message);
        end
    end
    if isinf(minTotalFrames)
        error('Could not determine minimum video length. Check video files and paths.');
    end
    fprintf('  Minimum video length found: %d frames.\n', minTotalFrames);

    endFrameFromConfig = round(labelingDurationMinutes * 60 * frameRate);
    actualEndFrame = min(endFrameFromConfig, minTotalFrames);
    effectiveDurationMinutes = actualEndFrame / frameRate / 60;
    if actualEndFrame > 0
        nFramesToLabelAdjusted = max(1, floor(effectiveDurationMinutes * framesPerMinute));
    else
        nFramesToLabelAdjusted = 0; 
    end
    if actualEndFrame < 1
        warning('Minimum video length or configured duration results in 0 frames available for sampling.')
        framesToLabelIndices = [];
    else
        framesToLabelIndices = round(linspace(1, actualEndFrame, nFramesToLabelAdjusted));
        framesToLabelIndices = unique(sort(framesToLabelIndices));
    end
    nFramesToLabel = numel(framesToLabelIndices);
    fprintf('Calculated %d frames to label based on duration/sampling, using actual end frame %d.\n', nFramesToLabel, actualEndFrame);
    % --- End of ORIGINAL frame calculation logic ---
end

% =========================================================================
% --- Load Camera Parameters ---
% =========================================================================
fprintf('Loading camera parameters from %s...\n', paramDir);

myCamParams = cell(numCameras, 1);
for i = 1:numCameras
    camName = labelingCameraNames{i};
    paramFile = fullfile(paramDir, camName + "_params.mat");

    if ~exist(paramFile, 'file')
        error('Parameter file not found: %s. Did create_label3d_calib_mats.py run correctly?', paramFile);
    end
    % fprintf('  Loading: %s\n', paramFile);
    loadedData = load(paramFile);
    % fprintf('    Loaded %s - r matrix:\n', camName);
    % disp(loadedData.r);
    % fprintf('    Loaded %s - t vector:\n', camName);
    % disp(loadedData.t);
    if ~isfield(loadedData, 'r')
       error('Field \'\'r\'\' not found in %s. Please re-run the Python script create_label3d_calib_mats.py after the latest update.', paramFile);
    end
    myCamParams{i} = loadedData;
end
fprintf('Loaded parameters for %d cameras.\n', numel(myCamParams));

% --- BEGIN LOGGING DATA PASSED TO Label3D ---
% fprintf('\n--- Verifying Data Structure Passed to Label3D ---\n');
% for i = 1:numCameras
%     camName = labelingCameraNames{i};
%     fprintf('  Camera %s (Index %d) Data:\n', camName, i);
%     fprintf('    myCamParams{%d}.r:\n', i);
%     disp(myCamParams{i}.r);
%     fprintf('    myCamParams{%d}.t:\n', i);
%     disp(myCamParams{i}.t);
% end
% fprintf('--- End Data Verification ---\n\n');
% --- END LOGGING DATA PASSED TO Label3D ---

% =========================================================================
% --- Load and Prepare Skeleton ---
% =========================================================================
fprintf('Loading and preparing skeleton...\n');

if ~exist(skeletonFile, 'file')
    error('Skeleton file not found: %s. Did create_coco_skeleton.py run correctly?', skeletonFile);
end
baseSkeletonData = load(skeletonFile);

fprintf('  Base skeleton loaded with %d joints.\n', numel(baseSkeletonData.joint_names));

fprintf('  Creating skeleton for %d animals...\n', nAnimals);
try
    multiAnimalSkel = multiAnimalSkeleton(baseSkeletonData, nAnimals);
catch ME
    if strcmp(ME.identifier, 'MATLAB:UndefinedFunction')
        error('multiAnimalSkeleton function not found. Ensure multiAnimalSkeleton.m is on the MATLAB path.');
    else
        rethrow(ME);
    end
end
fprintf('  Multi-animal skeleton created with %d total joints.\n', numel(multiAnimalSkel.joint_names));


% =========================================================================
% --- Load Video Frames ---
% =========================================================================

% --- Check for Cached Video Frames ---
videos = cell(numCameras, 1);
usedCache = false;
cacheFilename = '';
if enableVideoCache
    if ~exist(labelingOutputDir, 'dir')
       fprintf('Creating labeling output directory: %s\n', labelingOutputDir);
       mkdir(labelingOutputDir);
    end
    cacheFilename = fullfile(labelingOutputDir, sprintf('frameCache_n%d.mat', nFramesToLabel));
    if exist(cacheFilename, 'file')
        fprintf('Attempting to load video frames from cache: %s\n', cacheFilename);
        try
            cacheData = load(cacheFilename, 'videos', 'cachedFramesToLabelIndices', 'cachedVideoPaths');
            if isequal(cacheData.cachedFramesToLabelIndices, framesToLabelIndices) && ...
               isequal(cacheData.cachedVideoPaths, videoPaths) && ...
               numel(cacheData.videos) == numCameras && ...
               ~isempty(cacheData.videos) && ...
               (isempty(framesToLabelIndices) || (numel(cacheData.videos{1}) > 0 && size(cacheData.videos{1}, 4) == nFramesToLabel)) 
                fprintf('  Cache valid. Loading frames from cache...\n');
                videos = cacheData.videos;
                usedCache = true;
            else
                fprintf('  Cache invalid (parameters changed). Reloading frames.\n');
            end
        catch ME
             fprintf('  Error loading cache file: %s. Reloading frames.\n', ME.message);
        end
    end
end

% --- Load Frames if Cache Not Used ---
if ~usedCache
    if nFramesToLabel == 0
        fprintf('No frames selected to load (nFramesToLabel = 0). Skipping frame loading.\n');
        videos = cell(numCameras, 1);
        for i=1:numCameras
            videos{i} = zeros(0,0,3,0,'uint8'); 
        end
    else
        fprintf('Loading %d frames for each of %d videos...\n', nFramesToLabel, numCameras);
        videoHeight = 0; 
        videoWidth = 0;

        canUseParallel = false;
        if useParallel
            if license('test', 'Distrib_Computing_Toolbox') && ~isempty(ver('parallel'))
                canUseParallel = true;
                fprintf('  Parallel Computing Toolbox detected. Using parfor.\n');
            else
                fprintf('  Parallel Computing Toolbox not found or license unavailable. Using regular for loop.\n');
            end
        else
             fprintf('  Parallel processing disabled by user. Using regular for loop.\n');
        end

        startTime = tic;

        if canUseParallel
            pool = gcp('nocreate'); 
            if isempty(pool)
                parpool(); 
            end
            parfor i = 1:numCameras
                fprintf('  Processing video %d: %s\n', i, videoPaths{i});
                vr = VideoReader(videoPaths{i});
                videoData = zeros(vr.Height, vr.Width, 3, nFramesToLabel, 'uint8');
                for j = 1:nFramesToLabel
                    frameIdx = framesToLabelIndices(j);
                    if frameIdx > vr.NumFrames
                         warning('Frame index %d exceeds total frames (%d) in video %d. Skipping frame.', frameIdx, vr.NumFrames, i);
                         videoData(:,:,:,j) = 0; 
                    else
                        try
                            tempFrame = read(vr, frameIdx);
                            videoData(:,:,:,j) = tempFrame;
                        catch ME_read
                             warning('Error reading frame %d from video %d: %s. Skipping frame.', frameIdx, i, ME_read.message);
                             videoData(:,:,:,j) = 0;
                        end
                    end
                    if mod(j, 50) == 0 % Print progress periodically
                        fprintf('    Video %d: Loaded frame %d of %d\n', i, j, nFramesToLabel);
                    end
                end
                videos{i} = videoData;
                 fprintf('  Finished processing video %d.\n', i);
            end % end parfor
        else % Use regular for loop
            for i = 1:numCameras
                fprintf('  Processing video %d: %s\n', i, videoPaths{i});
                vr = VideoReader(videoPaths{i});
                if i == 1
                    videoHeight = vr.Height;
                    videoWidth = vr.Width;
                elseif isempty(videoHeight) || videoHeight==0 
                     videoHeight = vr.Height;
                     videoWidth = vr.Width;
                end
                
                % --- BEGIN DEBUG PRINT ---
                fprintf('  DEBUG (Before zeros): Cam %d, videoHeight=%s, videoWidth=%s, nFramesToLabel=%s\n', ...
                        i, mat2str(videoHeight), mat2str(videoWidth), mat2str(nFramesToLabel));
                % --- END DEBUG PRINT ---
                
                videoData = zeros(videoHeight, videoWidth, 3, nFramesToLabel, 'uint8'); 
                for j = 1:nFramesToLabel
                    frameIdx = framesToLabelIndices(j);
                    if frameIdx > vr.NumFrames
                         warning('Frame index %d exceeds total frames (%d) in video %d. Skipping frame.', frameIdx, vr.NumFrames, i);
                         videoData(:,:,:,j) = 0;
                    else
                         try
                            tempFrame = read(vr, frameIdx);
                            videoData(:,:,:,j) = tempFrame;
                         catch ME_read
                             warning('Error reading frame %d from video %d: %s. Skipping frame.', frameIdx, i, ME_read.message);
                             videoData(:,:,:,j) = 0;
                         end
                    end
                    if mod(j, 50) == 0 % Print progress periodically
                        fprintf('    Video %d: Loaded frame %d of %d\n', i, j, nFramesToLabel);
                    end
                end
                videos{i} = videoData;
                 fprintf('  Finished processing video %d.\n', i);
            end % end for
        end % end if canUseParallel

        elapsedTime = toc(startTime);
        fprintf('Finished loading all frames in %.2f seconds.\n', elapsedTime);
    end % end if nFramesToLabel > 0

    % --- Cache Video Frames ---
    if enableVideoCache && ~isempty(cacheFilename) && nFramesToLabel > 0 % Only save cache if frames were loaded
        fprintf('Saving loaded frames to cache: %s\n', cacheFilename);
        cachedFramesToLabelIndices = framesToLabelIndices; % Use the potentially adjusted indices
        cachedVideoPaths = videoPaths;
        try
            save(cacheFilename, 'videos', 'cachedFramesToLabelIndices', 'cachedVideoPaths', '-v7.3');
            fprintf('  Successfully saved frame cache.\n');
        catch ME_save
            fprintf('  Error saving frame cache: %s\n', ME_save.message);
        end
    elseif enableVideoCache && nFramesToLabel == 0
         fprintf('Skipping saving cache as no frames were loaded.\n');
    end
end % end if ~usedCache


% =========================================================================
% --- Launch Label3D ---
% =========================================================================
fprintf('Launching Label3D GUI...\n');

if ~exist(labelingOutputDir, 'dir')
   mkdir(labelingOutputDir);
end

if nFramesToLabel == 0
   warning('No frames were loaded. Cannot launch Label3D GUI.');
else
    try
        labelGui = Label3D(myCamParams, videos, multiAnimalSkel, ...
            'framesToLabel', framesToLabelIndices, ...
            'savePath', labelingOutputDir, ...
            'cameraNames', labelingCameraNames, ...
            'camPrefixMap', camNameToPrefixMap, ...
            'undistortedImages', true, ...
            'nAnimals', nAnimals);

        % --- Inject Precomputed 2D Poses (if enabled) ---
        if loadPrecomputedPoses
            if ~exist(precomputedPoseMatPath, 'file')
                warning('Precomputed pose .mat file not found: %s. Starting with empty labels.', precomputedPoseMatPath);
            else
                fprintf('Loading precomputed 2D poses from %s...\n', precomputedPoseMatPath);
                loadedData = load(precomputedPoseMatPath);
        
                requiredFields = {'precomputed_camPoints', 'precomputed_status', ...
                                  'processed_camera_names', 'processed_frame_ids', ...
                                  'discovered_instance_ids', 'num_keypoints_per_instance'};
                missingFields = setdiff(requiredFields, fieldnames(loadedData));
                if ~isempty(missingFields)
                    error('Precomputed pose .mat file (%s) is missing required fields: %s', precomputedPoseMatPath, strjoin(missingFields, ', '));
                end
        
                fprintf('  Validating .mat file contents...\n');
                
                mat_camPoints = loadedData.precomputed_camPoints;
                mat_status    = loadedData.precomputed_status;   
                mat_camera_names = cellstr(loadedData.processed_camera_names); 
                mat_frame_ids    = loadedData.processed_frame_ids;    
                mat_instance_ids = cellstr(loadedData.discovered_instance_ids); 
                mat_kpts_per_instance = loadedData.num_keypoints_per_instance;
        
                fprintf('  DEBUG: mat_kpts_per_instance from .mat file: %d\n', mat_kpts_per_instance); 
                fprintf('  DEBUG: nAnimals for session: %d\n', nAnimals); % nAnimals is session_nAnimals_check

                session_nAnimals_check = nAnimals; % From script's main config
                session_labelingCameraNames_check = labelingCameraNames; 
                session_framesToLabelIndices_check = framesToLabelIndices; 
                
                if numel(instanceIDsToLoadForSession) ~= session_nAnimals_check
                    error(['The number of instanceIDsToLoadForSession (%d) must match ', ...
                           'nAnimals configured for this Label3D session (%d).'], ...
                           numel(instanceIDsToLoadForSession), session_nAnimals_check);
                end
        
                session_to_mat_instance_slot_map = NaN(1, session_nAnimals_check);
                for i = 1:session_nAnimals_check
                    target_id = instanceIDsToLoadForSession{i};
                    mat_idx = find(strcmp(mat_instance_ids, target_id), 1);
                    if isempty(mat_idx)
                        warning('Instance ID "%s" specified in instanceIDsToLoadForSession not found in .mat file. Animal %d will have no preloaded points.', target_id, i);
                    else
                        session_to_mat_instance_slot_map(i) = mat_idx - 1; 
                    end
                end
        
                session_to_mat_cam_idx_map = NaN(1, numel(session_labelingCameraNames_check));
                for i = 1:numel(session_labelingCameraNames_check)
                    target_cam_name = session_labelingCameraNames_check{i};
                    mat_idx = find(strcmp(mat_camera_names, target_cam_name), 1);
                    if isempty(mat_idx)
                        warning('Camera "%s" specified for Label3D session not found in .mat file. This camera view will have no preloaded points.', target_cam_name);
                    else
                        session_to_mat_cam_idx_map(i) = mat_idx; 
                    end
                end
                
                session_to_mat_frame_idx_map = NaN(1, numel(session_framesToLabelIndices_check));
                for i = 1:numel(session_framesToLabelIndices_check)
                    target_frame_id = session_framesToLabelIndices_check(i);
                    mat_idx = find(mat_frame_ids == target_frame_id, 1);
                    if isempty(mat_idx)
                        warning('Frame ID %d specified for Label3D session not found in .mat file. Frame %d in session will have no preloaded points.', target_frame_id, i);
                    else
                        session_to_mat_frame_idx_map(i) = mat_idx; 
                    end
                end
        
                expected_gui_nMarkers = session_nAnimals_check * mat_kpts_per_instance;
                fprintf('  DEBUG: LabelGUI.nMarkers: %d, Calculated expected_gui_nMarkers: %d\n', labelGui.nMarkers, expected_gui_nMarkers);

                if labelGui.nMarkers ~= expected_gui_nMarkers
                    error('Mismatch in Label3D GUI markers (%d) vs. session setup calculation (%d). Check skeleton file used by Python vs. MATLAB, and nAnimals in this script. mat_kpts_per_instance was: %d', labelGui.nMarkers, expected_gui_nMarkers, mat_kpts_per_instance);
                end
        
                gui_camPoints = NaN(labelGui.nMarkers, numel(session_labelingCameraNames_check), 2, numel(session_framesToLabelIndices_check));
                gui_status    = zeros(labelGui.nMarkers, numel(session_labelingCameraNames_check), numel(session_framesToLabelIndices_check), 'uint8');
        
                fprintf('  Populating Label3D internal arrays with selected precomputed data...\n');
                for session_animal_idx = 1:session_nAnimals_check 
                    mat_instance_slot_idx_0based = session_to_mat_instance_slot_map(session_animal_idx); 
                    if isnan(mat_instance_slot_idx_0based)
                        continue; 
                    end
        
                    mat_marker_start_idx = (mat_instance_slot_idx_0based * mat_kpts_per_instance) + 1;
                    mat_marker_end_idx   = mat_marker_start_idx + mat_kpts_per_instance - 1;
        
                    gui_marker_start_idx = ((session_animal_idx-1) * mat_kpts_per_instance) + 1;
                    gui_marker_end_idx   = gui_marker_start_idx + mat_kpts_per_instance - 1;
        
                    for session_cam_logical_idx = 1:numel(session_labelingCameraNames_check) 
                        current_session_cam_name = session_labelingCameraNames_check{session_cam_logical_idx}; % Get current cam name

                        % *** Only load poses if this camera is in camerasToLoadPosesFor ***
                        if ~isempty(camerasToLoadPosesFor) && ~ismember(current_session_cam_name, string(camerasToLoadPosesFor)) 
                            % fprintf('  Skipping pose loading for camera %s as it is not in camerasToLoadPosesFor.\n', current_session_cam_name);
                            continue; % Skip to next session camera
                        end

                        mat_cam_actual_idx = session_to_mat_cam_idx_map(session_cam_logical_idx); 
                        if isnan(mat_cam_actual_idx)
                            % This warning is generated earlier if camera not found in .mat
                            continue; 
                        end
        
                        for session_frame_logical_idx = 1:numel(session_framesToLabelIndices_check) 
                            mat_frame_actual_idx = session_to_mat_frame_idx_map(session_frame_logical_idx); 
                            if isnan(mat_frame_actual_idx)
                                continue; 
                            end
                            
                            points_to_assign = mat_camPoints(mat_marker_start_idx:mat_marker_end_idx, mat_cam_actual_idx, :, mat_frame_actual_idx);
                            status_to_assign = mat_status(mat_marker_start_idx:mat_marker_end_idx, mat_cam_actual_idx, mat_frame_actual_idx);
                            
                            gui_camPoints(gui_marker_start_idx:gui_marker_end_idx, session_cam_logical_idx, :, session_frame_logical_idx) = points_to_assign;
                            gui_status(gui_marker_start_idx:gui_marker_end_idx, session_cam_logical_idx, session_frame_logical_idx) = status_to_assign;
                        end
                    end
                end
                
                labelGui.camPoints = gui_camPoints;
                labelGui.status    = gui_status;
        
                fprintf('  Precomputed 2D poses injected into Label3D session.\n');
                
                if ~isempty(labelGui.framesToLabel) && labelGui.frame > 0 && labelGui.frame <= numel(labelGui.framesToLabel)
                    labelGui.setFrame(labelGui.frame); 
                elseif ~isempty(labelGui.framesToLabel)
                     labelGui.setFrame(1); 
                end
                fprintf('  Label3D GUI refreshed.\n');
            end
        end
        % --- End Inject Precomputed 2D Poses ---

        fprintf('\nLabel3D GUI is running. Close the GUI window to end the session.\n');
        fprintf('Remember to use Shift+S within the GUI to save your progress frequently!\n');
        fprintf('Saved sessions will appear in: %s\n', labelingOutputDir);

    catch ME
        fprintf('\nError launching or running Label3D:\n');
        fprintf('%s\n', ME.getReport());
        fprintf('Please check paths, dependencies, and input data.\n');
        if exist('labelGui', 'var') && isvalid(labelGui) && isgraphics(labelGui.Parent)
             close(labelGui.Parent); % Attempt to close GUI on error
        end
    end
end